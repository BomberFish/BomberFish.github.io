{
  "version": 3,
  "sources": ["../../node_modules/dreamland/dist/dev.js"],
  "sourcesContent": ["\n// dreamland.js, MIT license\nconst DLFEATURES = ['css', 'jsxLiterals', 'usestring', 'stores'];\n(function (exports) {\n\n    const VERSION = '0.0.9';\n\n    // We add some extra properties into various objects throughout, better to use symbols and not interfere. this is just a tiny optimization\n    const [USE_MAPFN, TARGET, PROXY, STEPS, LISTENERS, IF, STATEHOOK] =\n        Array.from(Array(7), Symbol);\n\n    class DreamlandError extends Error {\n        constructor(message) {\n            super('[dreamland-js/dev] ' + message);\n            this.name = 'DreamlandDevError';\n        }\n    }\n\n    function log(message) {\n        console.log('[dreamland-js/dev] ' + message);\n    }\n\n    function panic(message) {\n        throw new DreamlandError('fatal: ' + message)\n    }\n\n    function assert(condition, message) {\n        if (!condition) {\n            panic(message);\n        }\n    }\n\n    // saves a few characters, since document will never change\n    let doc = document;\n\n    const Fragment = Symbol();\n\n    // whether to return the true value from a stateful object or a \"trap\" containing the pointer\n    let __use_trap = false;\n\n    // Say you have some code like\n    //// let state = $state({\n    ////    a: $state({\n    ////      b: 1\n    ////    })\n    //// })\n    //// let elm = <p>{window.use(state.a.b)}</p>\n    //\n    // According to the standard, the order of events is as follows:\n    // - the getter for window.use gets called, setting __use_trap true\n    // - the proxy for state.a is triggered and instead of returning the normal value it returns the trap\n    // - the trap proxy is triggered, storing [\"a\", \"b\"] as the order of events\n    // - the function that the getter of `use` returns is called, setting __use_trap to false and restoring order\n    // - the JSX factory h() is now passed the trap, which essentially contains a set of pointers pointing to the theoretical value of b\n    // - with the setter on the stateful proxy, we can listen to any change in any of the nested layers and call whatever listeners registered\n    // - the result is full intuitive reactivity with minimal overhead\n    Object.defineProperty(window, 'use', {\n        get: () => {\n            __use_trap = true;\n            return (ptr, mapping, ...rest) => {\n                /* FEATURE.USESTRING.START */\n                if (ptr instanceof Array) return usestr(ptr, mapping, ...rest)\n                /* FEATURE.USESTRING.END */\n                assert(\n                    isDLPtr(ptr),\n                    'a value was passed into use() that was not part of a stateful context'\n                );\n                __use_trap = false;\n                if (mapping) ptr[USE_MAPFN] = mapping;\n                return ptr\n            }\n        },\n    });\n\n    /* FEATURE.USESTRING.START */\n    const usestr = (strings, ...values) => {\n        __use_trap = false;\n\n        let state = $state({});\n        const flattened_template = [];\n        for (const i in strings) {\n            flattened_template.push(strings[i]);\n            if (values[i]) {\n                const prop = values[i];\n\n                if (isDLPtr(prop)) {\n                    const current_i = flattened_template.length;\n                    let oldparsed;\n                    handle(prop, (val) => {\n                        flattened_template[current_i] = String(val);\n                        let parsed = flattened_template.join('');\n                        if (parsed != oldparsed) state.string = parsed;\n                        oldparsed = parsed;\n                    });\n                } else {\n                    flattened_template.push(String(prop));\n                }\n            }\n        }\n\n        state.string = flattened_template.join('');\n\n        return use(state.string)\n    };\n    /* FEATURE.USESTRING.END */\n\n    let TRAPS = new Map();\n    // This wraps the target in a proxy, doing 2 things:\n    // - whenever a property is accessed, return a \"trap\" that catches and records accessors\n    // - whenever a property is set, notify the subscribed listeners\n    // This is what makes our \"pass-by-reference\" magic work\n    function $state(target) {\n        assert(isobj(target), '$state() requires an object');\n        target[LISTENERS] = [];\n        target[TARGET] = target;\n        let TOPRIMITIVE = Symbol.toPrimitive;\n\n        let proxy = new Proxy(target, {\n            get(target, property, proxy) {\n                if (__use_trap) {\n                    let sym = Symbol();\n                    let trap = new Proxy(\n                        {\n                            [TARGET]: target,\n                            [PROXY]: proxy,\n                            [STEPS]: [property],\n                            [TOPRIMITIVE]: (_) => sym,\n                        },\n                        {\n                            get(target, property) {\n                                if (\n                                    [\n                                        TARGET,\n                                        PROXY,\n                                        STEPS,\n                                        USE_MAPFN,\n                                        TOPRIMITIVE,\n                                    ].includes(property)\n                                )\n                                    return target[property]\n                                property = TRAPS.get(property) || property;\n                                target[STEPS].push(property);\n                                return trap\n                            },\n                        }\n                    );\n                    TRAPS.set(sym, trap);\n\n                    return trap\n                }\n                return Reflect.get(target, property, proxy)\n            },\n            set(target, property, val) {\n                let trap = Reflect.set(target, property, val);\n                for (let listener of target[LISTENERS]) {\n                    listener(target, property, val);\n                }\n\n                /* FEATURE.STORES.START */\n                if (target[STATEHOOK])\n                    target[STATEHOOK](target, property, target[property]);\n                /* FEATURE.STORES.END */\n\n                return trap\n            },\n        });\n\n        return proxy\n    }\n\n    let isobj = (o) => o instanceof Object;\n    let isfn = (o) => typeof o === 'function';\n\n    function isStateful(obj) {\n        return isobj(obj) && LISTENERS in obj\n    }\n\n    function isDLPtr(arr) {\n        return isobj(arr) && STEPS in arr\n    }\n\n    function $if(condition, then, otherwise) {\n        otherwise ??= doc.createTextNode('');\n        if (!isDLPtr(condition)) return condition ? then : otherwise\n\n        return { [IF]: condition, then, otherwise }\n    }\n\n    // This lets you subscribe to a stateful object\n    function handle(ptr, callback) {\n        assert(isDLPtr(ptr), 'handle() requires a stateful object');\n        assert(isfn(callback), 'handle() requires a callback function');\n        let step,\n            resolvedSteps = [];\n\n        function update() {\n            let val = ptr[TARGET];\n            for (step of resolvedSteps) {\n                val = val[step];\n                if (!isobj(val)) break\n            }\n\n            let mapfn = ptr[USE_MAPFN];\n            if (mapfn) val = mapfn(val);\n            callback(val);\n        }\n\n        // inject ourselves into nested objects\n        let curry = (target, i) =>\n            function subscription(tgt, prop, val) {\n                if (prop === resolvedSteps[i] && target === tgt) {\n                    update();\n\n                    if (isobj(val)) {\n                        let v = val[LISTENERS];\n                        if (v && !v.includes(subscription)) {\n                            v.push(curry(val[TARGET], i + 1));\n                        }\n                    }\n                }\n            };\n\n        // imagine we have a `use(state.a[state.b])`\n        // simply recursively resolve any of the intermediate steps until we get to the final value\n        // this will \"misfire\" occassionaly with a scenario like state.a[state.b][state.c] and call the listener more than needed\n        // it is up to the caller to not implode\n        for (let i in ptr[STEPS]) {\n            let step = ptr[STEPS][i];\n            if (isobj(step) && step[TARGET]) {\n                handle(step, (val) => {\n                    resolvedSteps[i] = val;\n                    update();\n                });\n                continue\n            }\n            resolvedSteps[i] = step;\n        }\n\n        let sub = curry(ptr[TARGET], 0);\n        ptr[TARGET][LISTENERS].push(sub);\n\n        sub(ptr[TARGET], resolvedSteps[0], ptr[TARGET][resolvedSteps[0]]);\n    }\n\n    function JSXAddFixedWrapper(ptr, cb, $if) {\n        let before, appended, first, flag;\n        handle(ptr, (val) => {\n            first = appended?.[0];\n            if (first) before = first.previousSibling || (flag = first.parentNode);\n            if (appended) appended.forEach((a) => a.remove());\n\n            appended = JSXAddChild(\n                $if ? (val ? $if.then : $if.otherwise) : val,\n                (el) => {\n                    if (before) {\n                        if (flag) {\n                            before.prepend(el);\n                            flag = null;\n                        } else before.after(el);\n                        before = el;\n                    } else cb(el);\n                }\n            );\n        });\n    }\n\n    // returns a function that sets a reference\n    // the currying is a small optimization\n    let curryset = (ptr) => (val) => {\n        let next = ptr[PROXY];\n        let steps = ptr[STEPS];\n        let i = 0;\n        for (; i < steps.length - 1; i++) {\n            next = next[steps[i]];\n            if (!isobj(next)) return\n        }\n        next[steps[i]] = val;\n    };\n\n    // Actual JSX factory. Responsible for creating the HTML elements and all of the *reactive* syntactic sugar\n    function h(type, props, ...children) {\n        if (type == Fragment) return children\n        if (typeof type == 'function') {\n            // functional components. create the stateful object\n            let newthis = $state(Object.create(type.prototype));\n\n            for (let name in props) {\n                let ptr = props[name];\n                if (name.startsWith('bind:')) {\n                    assert(\n                        isDLPtr(ptr),\n                        'bind: requires a reference pointer from use'\n                    );\n\n                    let set = curryset(ptr);\n                    let propname = name.substring(5);\n                    if (propname == 'this') {\n                        set(newthis);\n                    } else {\n                        // component two way data binding!! (exact same behavior as svelte:bind)\n                        let isRecursive = false;\n\n                        handle(ptr, (value) => {\n                            if (isRecursive) {\n                                isRecursive = false;\n                                return\n                            }\n                            isRecursive = true;\n                            newthis[propname] = value;\n                        });\n                        handle(use(newthis[propname]), (value) => {\n                            if (isRecursive) {\n                                isRecursive = false;\n                                return\n                            }\n                            isRecursive = true;\n                            set(value);\n                        });\n                    }\n                    delete props[name];\n                }\n            }\n            Object.assign(newthis, props);\n\n            newthis.children = [];\n            for (let child of children) {\n                JSXAddChild(child, newthis.children.push.bind(newthis.children));\n            }\n\n            let elm = type.apply(newthis);\n            elm.$ = newthis;\n            newthis.root = elm;\n            if (newthis.css) {\n                let cl = elm.classList;\n                cl.add(newthis.css);\n                cl.add('dl-boundary');\n            }\n            elm.setAttribute('data-component', type.name);\n            if (typeof newthis.mount === 'function') newthis.mount();\n            return elm\n        }\n\n        let xmlns = props?.xmlns;\n        let elm = xmlns ? doc.createElementNS(xmlns, type) : doc.createElement(type);\n\n        for (let child of children) {\n            let cond = child && !isDLPtr(child) && child[IF];\n            let bappend = elm.append.bind(elm);\n            if (cond) {\n                JSXAddFixedWrapper(cond, bappend, child);\n            } else JSXAddChild(child, bappend);\n        }\n\n        if (!props) return elm\n\n        let useProp = (name, callback) => {\n            if (!(name in props)) return\n            let prop = props[name];\n            callback(prop);\n            delete props[name];\n        };\n\n        for (let name in props) {\n            let ptr = props[name];\n            if (name.startsWith('bind:')) {\n                assert(isDLPtr(ptr), 'bind: requires a reference pointer from use');\n                let propname = name.substring(5);\n\n                // create the function to set the value of the pointer\n                let set = curryset(ptr);\n                if (propname == 'this') {\n                    set(elm);\n                } else if (propname == 'value') {\n                    handle(ptr, (value) => (elm.value = value));\n                    elm.addEventListener('change', () => set(elm.value));\n                } else if (propname == 'checked') {\n                    handle(ptr, (value) => (elm.checked = value));\n                    elm.addEventListener('click', () => set(elm.checked));\n                }\n                delete props[name];\n            }\n            if (name == 'style' && isobj(ptr)) {\n                for (let key in ptr) {\n                    let prop = ptr[key];\n                    if (isDLPtr(prop)) {\n                        handle(prop, (value) => (elm.style[key] = value));\n                    } else {\n                        elm.style[key] = prop;\n                    }\n                }\n                delete props[name];\n            }\n        }\n\n        useProp('class', (classlist) => {\n            assert(\n                typeof classlist === 'string' || classlist instanceof Array,\n                'class must be a string or array'\n            );\n            if (typeof classlist === 'string') {\n                elm.setAttribute('class', classlist);\n                return\n            }\n\n            if (isDLPtr(classlist)) {\n                handle(classlist, (classname) =>\n                    elm.setAttribute('class', classname)\n                );\n                return\n            }\n\n            for (let name of classlist) {\n                if (isDLPtr(name)) {\n                    let oldvalue = null;\n                    handle(name, (value) => {\n                        if (typeof oldvalue === 'string') {\n                            elm.classList.remove(oldvalue);\n                        }\n                        elm.classList.add(value);\n                        oldvalue = value;\n                    });\n                } else {\n                    elm.classList.add(name);\n                }\n            }\n        });\n\n        // apply the non-reactive properties\n        for (let name in props) {\n            let prop = props[name];\n            if (isDLPtr(prop)) {\n                handle(prop, (val) => {\n                    JSXAddAttributes(elm, name, val);\n                });\n            } else {\n                JSXAddAttributes(elm, name, prop);\n            }\n        }\n\n        // hack to fix svgs\n        if (xmlns) elm.innerHTML = elm.innerHTML;\n\n        return elm\n    }\n\n    // glue for nested children\n    function JSXAddChild(child, cb) {\n        let childchild, elms, node;\n        if (isDLPtr(child)) {\n            JSXAddFixedWrapper(child, cb);\n        } else if (child instanceof Node) {\n            cb(child);\n            return [child]\n        } else if (child instanceof Array) {\n            elms = [];\n            for (childchild of child) {\n                elms = elms.concat(JSXAddChild(childchild, cb));\n            }\n            if (!elms[0]) elms = JSXAddChild('', cb);\n            return elms\n        } else {\n            node = doc.createTextNode(child);\n            cb(node);\n            return [node]\n        }\n    }\n\n    // Where properties are assigned to elements, and where the *non-reactive* syntax sugar goes\n    function JSXAddAttributes(elm, name, prop) {\n        if (name.startsWith('on:')) {\n            assert(typeof prop === 'function', 'on: requires a function');\n            let names = name.substring(3);\n            for (let name of names.split('$')) {\n                elm.addEventListener(name, (...args) => {\n                    self.$el = elm;\n                    prop(...args);\n                });\n            }\n            return\n        }\n\n        elm.setAttribute(name, prop);\n    }\n\n    const cssmap = {};\n\n    function css(strings, ...values) {\n        let str = '';\n        for (let f of strings) {\n            str += f + (values.shift() || '');\n        }\n\n        let cached = cssmap[str];\n        if (cached) return cached\n\n        const uid = `dl${Array(5)\n        .fill(0)\n        .map(() => {\n            return Math.floor(Math.random() * 36).toString(36)\n        })\n        .join('')}`;\n\n        cssmap[str] = uid;\n        const styleElement = document.createElement('style');\n        document.head.appendChild(styleElement);\n\n        let newstr = '';\n        let selfstr = '';\n\n        // compat layer for older browsers. when css nesting stablizes this can be removed\n        str += '\\n';\n        for (;;) {\n            let [first, ...rest] = str.split('\\n');\n            if (first.trim().endsWith('{')) break\n\n            selfstr += first + '\\n';\n            str = rest.join('\\n');\n            if (!str) break\n        }\n        styleElement.textContent = str;\n\n        for (const rule of styleElement.sheet.cssRules) {\n            rule.selectorText = `.${uid} ${rule.selectorText}`;\n            newstr += rule.cssText + '\\n';\n        }\n\n        styleElement.textContent = `.${uid} {${selfstr}}` + '\\n' + newstr;\n\n        return uid\n    }\n\n    function html(strings, ...values) {\n        let flattened = '';\n        let markers = {};\n        for (const i in strings) {\n            let string = strings[i];\n            let value = values[i];\n\n            flattened += string;\n            if (i < values.length) {\n                let dupe = Object.values(markers).findIndex((v) => v == value);\n                if (dupe !== -1) {\n                    flattened += Object.keys(markers)[dupe];\n                } else {\n                    let marker =\n                        'm' +\n                        Array(16)\n                            .fill(0)\n                            .map(() => Math.floor(Math.random() * 16).toString(16))\n                            .join('');\n                    markers[marker] = value;\n                    flattened += marker;\n                }\n            }\n        }\n        let dom = new DOMParser().parseFromString(flattened, 'text/html');\n        if (dom.body.children.length !== 1)\n            throw 'html builder needs exactly one child'\n\n        function wraph(elm) {\n            let nodename = elm.nodeName.toLowerCase();\n            if (nodename === '#text') return elm.textContent\n            if (nodename in markers) nodename = markers[nodename];\n\n            let children = [...elm.childNodes].map(wraph);\n            for (let i = 0; i < children.length; i++) {\n                let text = children[i];\n                if (typeof text !== 'string') continue\n                for (const [marker, value] of Object.entries(markers)) {\n                    if (!text) break\n                    if (!text.includes(marker)) continue\n                    let before\n                    ;[before, text] = text.split(marker);\n                    children = [\n                        ...children.slice(0, i),\n                        before,\n                        value,\n                        text,\n                        ...children.slice(i + 1),\n                    ];\n                    i += 2;\n                }\n            }\n\n            let attributes = {};\n            for (const attr of [...elm.attributes]) {\n                let val = attr.nodeValue;\n                if (val in markers) val = markers[val];\n                attributes[attr.name] = val;\n            }\n\n            return h(nodename, attributes, children)\n        }\n\n        return wraph(dom.body.children[0])\n    }\n\n    const delegates = [];\n\n    function $store(target, { ident, backing, autosave }) {\n        let read, write;\n        if (typeof backing === 'string') {\n            switch (backing) {\n                case 'localstorage':\n                    read = () => localStorage.getItem(ident);\n                    write = (ident, data) => {\n                        localStorage.setItem(ident, data);\n                    };\n                    break\n                default:\n                    assert('Unknown store type: ' + backing);\n            }\n        } else {\n    ({ read, write } = backing);\n        }\n\n        let save = () => {\n            console.info('[dreamland.js]: saving ' + ident);\n\n            // stack gets filled with \"pointers\" representing unique objects\n            // this is to avoid circular references\n\n            let serstack = {};\n            let vpointercount = 0;\n\n            let ser = (tgt) => {\n                let obj = {\n                    stateful: isStateful(tgt),\n                    values: {},\n                };\n                let i = vpointercount++;\n                serstack[i] = obj;\n\n                for (let key in tgt) {\n                    let value = tgt[key];\n\n                    if (isDLPtr(value)) continue // i don\"t think we should be serializing pointers?\n                    switch (typeof value) {\n                        case 'string':\n                        case 'number':\n                        case 'boolean':\n                        case 'undefined':\n                            obj.values[key] = JSON.stringify(value);\n                            break\n\n                        case 'object':\n                            if (value instanceof Array) {\n                                obj.values[key] = value.map((v) => {\n                                    if (typeof v === 'object') {\n                                        return ser(v)\n                                    } else {\n                                        return JSON.stringify(v)\n                                    }\n                                });\n                                break\n                            } else {\n                                assert(\n                                    value.__proto__ === Object.prototype,\n                                    'Only plain objects are supported'\n                                );\n                                obj.values[key] = ser(value);\n                            }\n                            break\n\n                        case 'symbol':\n                        case 'function':\n                        case 'bigint':\n                            assert('Unsupported type: ' + typeof value);\n                            break\n                    }\n                }\n\n                return i\n            };\n            ser(target);\n\n            let string = JSON.stringify(serstack);\n            write(ident, string);\n        };\n\n        let autohook = (target, prop, value) => {\n            if (isStateful(value)) value[TARGET][STATEHOOK] = autohook;\n            save();\n        };\n\n        let destack = JSON.parse(read(ident));\n        if (destack) {\n            let objcache = {};\n\n            let de = (i) => {\n                if (objcache[i]) return objcache[i]\n                let obj = destack[i];\n                let tgt = {};\n                for (let key in obj.values) {\n                    let value = obj.values[key];\n                    if (typeof value === 'string') {\n                        tgt[key] = JSON.parse(value);\n                    } else {\n                        if (value instanceof Array) {\n                            tgt[key] = value.map((v) => {\n                                if (typeof v === 'string') {\n                                    return JSON.parse(v)\n                                } else {\n                                    return de(v)\n                                }\n                            });\n                        } else {\n                            tgt[key] = de(value);\n                        }\n                    }\n                }\n                if (obj.stateful && autosave == 'auto') tgt[STATEHOOK] = autohook;\n                let newobj = obj.stateful ? $state(tgt) : tgt;\n                objcache[i] = newobj;\n                return newobj\n            };\n\n            target = de(0);\n        }\n\n        delegates.push(save);\n        switch (autosave) {\n            case 'beforeunload':\n                addEventListener('beforeunload', save);\n                break\n            case 'manual':\n                break\n            case 'auto':\n                target[STATEHOOK] = autohook;\n                break\n            default:\n                assert('Unknown autosave type: ' + autosave);\n        }\n\n        return $state(target)\n    }\n\n    function saveAllStores() {\n        delegates.forEach((cb) => cb());\n    }\n\n    log('Version: ' + VERSION);\n    console.warn(\n        'This is a DEVELOPER build of dreamland.js. It is not suitable for production use.'\n    );\n    console.info('Enabled features:', DLFEATURES.join(', '));\n    /* DEV.END */\n\n    exports.$if = $if;\n    exports.$state = $state;\n    exports.$store = $store;\n    exports.DLVERSION = VERSION;\n    exports.Fragment = Fragment;\n    exports.css = css;\n    exports.h = h;\n    exports.handle = handle;\n    exports.html = html;\n    exports.isDLPtr = isDLPtr;\n    exports.isStateful = isStateful;\n    exports.saveAllStores = saveAllStores;\n    exports.stateful = $state;\n\n})(window)\n//# sourceMappingURL=dev.js.map\n"],
  "mappings": "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",
  "names": ["target", "proxy", "property", "step", "$if", "elm", "name", "ident"]
}
